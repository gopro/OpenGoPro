var store = [{
        "title": "BlueZ Bash Tutorial",
        "excerpt":"This document will provide a walk-through tutorial to use BlueZ to interact with the Open GoPro Interface. It is ok not to have read the interface documentation first as we will describe it as needed here. After completing this tutorial, you will need to reference it for future development.   Requirements   Hardware      A platform that is supported by Bluez   A GoPro camera that is supported by Open GoPro   Software      BlueZ must be installed. Follow the steps here   Test that installation was successful with:   $ bluetoothctl --version bluetoothctl: 5.58   Basic BLE Tutorial   This tutorial will walk through a process of connecting to the GoPro via Bluetooth Low Energy (BLE) and taking a picture / video.   First, invoke the bluetooth control tool from BlueZ with:   $ bluetoothctl Agent registered [CHG] Controller FC:44:82:DD:5A:3F Pairable: yes [bluetooth]#   Advertise   Now, we need to ensure the camera is discoverable (i.e. it is advertising). Ensure that the Camera is powered on, then select Connections ‚Äì&gt; Connect Device ‚Äì&gt; Quik App   The screen should appear as such:                     Camera is discoverable.              This step may vary slightly by camera  Scan                                               code                                                     output                                                     Input                                                     Output                                                                Next, we must find the GoPro Camera using bleak. Let‚Äôs initialize an empty dict that will store discovered devices, indexed by name:   # Map of devices indexed by name devices: Dict[str, BleakDevice] = {}   We‚Äôre then going to scan for all devices. We are passing a scan callback to bleak in order to also find non-connectable scan responses. We are keeping any devices that have a device name.   # Scan callback to also catch nonconnectable scan responses def _scan_callback(device: BleakDevice, _: Any) -&gt; None:     # Add to the dict if not unknown     if device.name != \"Unknown\" and device.name is not None:         devices[device.name] = device  # Now discover and add connectable advertisements for device in await BleakScanner.discover(timeout=5, detection_callback=_scan_callback):     if device.name != \"Unknown\" and device.name is not None:         devices[device.name] = device   Now we can search through the discovered devices to see if we found a GoPro. Any GoPro device name will be structured as GoPro XXXX where XXXX is the last four digits of your camera‚Äôs serial number.   First, we define a regex which is either ‚ÄúGoPro ‚Äú followed by any four digits if no identifier was passed, or ‚ÄúGoPro ‚Äú concatenated with the identifier if it exists. In the demo ble_connect.py, the identifier is taken from the command-line arguments.   token = re.compile(r\"GoPro \\d\\d\\d\\d\" if identifier is None else f\"GoPro {identifier}\")   Now we build a list of matched devices by checking if each device‚Äôs name includes the token regex.   matched_devices: List[BleakDevice] = [] # Now look for our matching device(s) matched_devices = [device for name, device in devices.items() if token.match(name)]   Due to potential RF interference and the asynchronous nature of BLE advertising / scanning, it is possible that the advertising GoPro will not be discovered by the scanning PC in one scan. Therefore, you may need to redo the scan (as ble_connect.py does) until a GoPro is found. That is, matched_device must contain at least one device.   When running the demo, discovered devices will be logged to the console as they are found. Click the output tab to see an example of this.                          Here is an example of the log from `ble_connect.py` of scanning for devices. Note that this includes several rescans until the devices was found.  $ python ble_connect.py INFO:root:Scanning for bluetooth devices... INFO:root:      Discovered: INFO:root:      Discovered: TR8600 seri INFO:root:Found 0 matching devices. INFO:root:      Discovered: INFO:root:      Discovered: TR8600 seri INFO:root:      Discovered: GoPro Cam INFO:root:      Discovered: GoPro 0456 INFO:root:Found 1 matching devices.   Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera‚Äôs serial number.                          Next, we must find the GoPro Camera from BlueZ. Scan for devices via:   [bluetooth]# scan on   As BlueZ discovers devices, it will display them to the console.   Click the output tab to see the output.                          [bluetooth]# scan on Discovery started [CHG] Controller FC:44:82:DD:5A:3F Discovering: yes [NEW] Device 6E:0A:B0:76:36:49 6E-0A-B0-76-36-49 [NEW] Device DF:34:ED:D1:DA:E8 GoPro 0456 [NEW] Device 26:A2:8C:82:74:6E 26-A2-8C-82-74-6E [CHG] Device F8:A2:6D:4C:5D:E0 RSSI: -60   Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera‚Äôs serial number. Take note of the address to the left of this string (DF:34:ED:D1:DA:E8 in the example above). This is how the camera will be identified via bluetoothctl.                    Connect                                               Input                                                     Output                                                                Now that we know the address to connect to, the next step is to establish a BLE connection to the camera as such:   [bluetooth]# connect DF:34:ED:D1:DA:E8   Click the output tab to see the output.                          When the connection is successfully established, the list of services and characteristics will be displayed as such:   We will make use of these attributes later on.   [CHG] Device DF:34:ED:D1:DA:E8 Connected: yes Connection successful [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0001         00001801-0000-1000-8000-00805f9b34fb         Generic Attribute Profile [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000b         00001804-0000-1000-8000-00805f9b34fb         Tx Power [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000b/char000c         00002a07-0000-1000-8000-00805f9b34fb         Tx Power Level [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e         0000180f-0000-1000-8000-00805f9b34fb         Battery Service [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e/char000f         00002a19-0000-1000-8000-00805f9b34fb         Battery Level [NEW] Descriptor (Handle 0xea04)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e/char000f/desc0011         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012         0000180a-0000-1000-8000-00805f9b34fb         Device Information [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0013         00002a29-0000-1000-8000-00805f9b34fb         Manufacturer Name String [NEW] Characteristic (Handle 0xea8d)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0015         00002a24-0000-1000-8000-00805f9b34fb         Model Number String [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0017         00002a25-0000-1000-8000-00805f9b34fb         Serial Number String [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0019         00002a27-0000-1000-8000-00805f9b34fb         Hardware Revision String [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001b         00002a26-0000-1000-8000-00805f9b34fb         Firmware Revision String [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001d         00002a28-0000-1000-8000-00805f9b34fb         Software Revision String [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001f         00002a23-0000-1000-8000-00805f9b34fb         System ID [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0021         00002a2a-0000-1000-8000-00805f9b34fb         IEEE 11073-20601 Regulatory Cert. Data List [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0023         00002a50-0000-1000-8000-00805f9b34fb         PnP ID [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025         b5f90001-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char0026         b5f90002-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char0028         b5f90003-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002a         b5f90004-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002c         b5f90005-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x32a4)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002c/desc002e         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002f         b5f90006-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031         0000fea6-0000-1000-8000-00805f9b34fb         GoPro, Inc. [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0032         b5f90072-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0034         b5f90073-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x4174)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0034/desc0036         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0037         b5f90074-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0039         b5f90075-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x4b84)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0039/desc003b         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003c         b5f90076-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003e         b5f90077-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x5494)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003e/desc0040         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0041         b5f90078-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0043         b5f90079-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x5da4)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0043/desc0045         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046         b5f90090-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0047         b5f90091-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0049         b5f90092-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x6984)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0049/desc004b         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c         b5f90080-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char004d         b5f90081-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x7274)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char004d/desc004f         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0050         b5f90082-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0052         b5f90083-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x8104)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0052/desc0054         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0055         b5f90084-aa8d-11e3-9046-0002a5d5c51b         Vendor specific [NEW] Descriptor (Handle 0x8724)         /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0055/desc0057         00002902-0000-1000-8000-00805f9b34fb         Client Characteristic Configuration [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001800-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001801-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001804-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000180a-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000180f-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000fea6-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90001-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90080-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90090-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 ServicesResolved: yes [CHG] Device DF:34:ED:D1:DA:E8 Appearance: 0x0080 [CHG] Device DF:34:ED:D1:DA:E8 Icon: computer [NEW] Device 6C:4A:85:45:04:D4 6C-4A-85-45-04-D4 [GoPro 0456]#                    Pair   The GoPro has encryption-protected characteristics which require us to pair before writing to. Now that you are connected (the prompt should now show GoPro XXXX instead of bluetooth), do:   [GoPro 0456]# pair Attempting to pair with DF:34:ED:D1:DA:E8 [CHG] Device DF:34:ED:D1:DA:E8 Paired: yes Pairing successful   Once paired, the camera should beep and display ‚ÄúConnection Successful‚Äù. Also, the device should show up when querying bluetoothctl for paired devices:   [GoPro 0456]# paired-devices Device DF:34:ED:D1:DA:E8 GoPro 0456     It is now no longer necessary to pair on subsequent connections.  Enable Notifications                                               Enter Gatt Menu                                                     Enable Notifications                                                                As specified in the Open GoPro Bluetooth API, we must enable notifications for a given characteristic to receive responses from it. First, let‚Äôs enter the gatt submenu:   [GoPro 0456]# menu gatt Menu gatt: Available commands: ------------------- list-attributes [dev/local]                       List attributes select-attribute &lt;attribute/UUID&gt;                 Select attribute attribute-info [attribute/UUID]                   Select attribute read [offset]                                     Read attribute value write &lt;data=xx xx ...&gt; [offset] [type]            Write attribute value acquire-write                                     Acquire Write file descriptor release-write                                     Release Write file descriptor acquire-notify                                    Acquire Notify file descriptor release-notify                                    Release Notify file descriptor notify &lt;on/off&gt;                                   Notify attribute value clone [dev/attribute/UUID]                        Clone a device or attribute register-application [UUID ...]                   Register profile to connect unregister-application                            Unregister profile register-service &lt;UUID&gt; [handle]                  Register application service. unregister-service &lt;UUID/object&gt;                  Unregister application service register-includes &lt;UUID&gt; [handle]                 Register as Included service in. unregister-includes &lt;Service-UUID&gt;&lt;Inc-UUID&gt;      Unregister Included service. register-characteristic &lt;UUID&gt; &lt;Flags=read,write,notify...&gt; [handle] Register application characteristic unregister-characteristic &lt;UUID/object&gt;           Unregister application characteristic register-descriptor &lt;UUID&gt; &lt;Flags=read,write...&gt; [handle] Register application descriptor unregister-descriptor &lt;UUID/object&gt;               Unregister application descriptor back                                              Return to main menu version                                           Display version quit                                              Quit program exit                                              Quit program help                                              Display help about this program export                                            Print environment variables   Go the the next tab to enable notifications                          Now, we need to enable notifications for the relevant characteristic. In this demo, we will only be setting the shutter. This command is sent on the ‚ÄúCommand Request‚Äù characteristic and it‚Äôs responses are received as notifications on the ‚ÄúCommand Response‚Äù characteristic. So we only care about the ‚ÄúCommand Response‚Äù characteristic which has UUID b5f90073-aa8d-11e3-9046-0002a5d5c51b.      You can see this UUID listed above when the connection was formed. All attributes can also be found again from bluetoothctl with list-attributes    To enable notifications, select the attribute then enable notifications:   [GoPro 0456]# select-attribute b5f90073-aa8d-11e3-9046-0002a5d5c51b [GoPro 0456:/service0031/char0034]# acquire-notify [CHG] Attribute /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 NotifyAcquired: yes AcquireNotify success: fd 7 MTU 335   Since we are acquiring (using the BlueZ terminology as in the command) notifications, this means that we will be alerted of responses when the characteristic is notified.                    Quiz time! üìö ‚úèÔ∏è                 How are responses to the Command Request characteristic received over BLE?                               A: As write responses to the Command Request characteristic                                    B: As notifications of the Command Response characteristic                                    C: There is no response since this characteristic is Write-without-Response                                    D: They must be polled by reading the Command Response characteristic                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is B.         All GoPro commands follow the same behavior: a command is first sent on a request characteristic.     The response is then notified on the response characteristic (assuming notifications are enabled).                      How often is it necessary to pair?                               A: Pairing must occur every time to ensure safe BLE communication                                    B: We never need to pair as the GoPro does not require it to communicate                                    C: Pairing only needs to occur once as BlueZ will automatically re-use the shared keys for future connections                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         Pairing is only needed once (assuming neither side deletes the keys). If the     GoPro deletes the keys (via Connections-&gt;Reset Connections or a factory reset), the devices will need to re-pair.        Sending Commands   Now that we are are connected, paired, and have enabled notifications, we can send commands. The command we will be sending is Set Shutter, which at byte level is:                  Command       Bytes                       Set Shutter Off       0x03 0x01 0x01 0x00                 Set Shutter On       0x03 0x01 0x01 0x01           First, we need to choose the attribute to write to which is the ‚ÄúCommand Request‚Äù characteristic with UUID b5f90072-aa8d-11e3-9046-0002a5d5c51b. This is done via select-attribute:   [GoPro 0456:/service0031/char0034]# select-attribute b5f90072-aa8d-11e3-9046-0002a5d5c51b [GoPro 0456:/service0031/char0032]# attribute-info Characteristic - Vendor specific         UUID: b5f90072-aa8d-11e3-9046-0002a5d5c51b         Service: /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031         Flags: write     As a bonus, you can then call \"attribute-info\" to verify that this characteristic is writeable.  Send Commands                                               Set Shutter On                                                     Set Shutter Off                                                                Now, let‚Äôs write the bytes to turn the shutter on and start encoding!   [GoPro 0456:/service0031/char0032]# write \"0x03 0x01 0x01 0x01\" Attempting to write /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0032 [CHG] /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 Notification:   02 01 00   You should hear the camera beep and it will either take a picture or start recording depending on what mode it is in.   Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we acquired it‚Äôs notifications in [Enable Notifications]   If you are recording a video, go to the next tab to set the shutter off.                          We can now set the shutter off:   [GoPro 0456:/service0031/char0032]# write \"0x03 0x01 0x01 0x00\" Attempting to write /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0032 [CHG] /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 Notification:   02 01 00                    Good Job!     Congratulations ü§ô  You can now send any of the other BLE commands detailed in the Open GoPro documentation in a similar manner.   Troubleshooting   GoPro Stops Advertising   Sometimes the GoPro will stop advertising. A quick fix at this point is to power cycle the camera by pulling and then re-inserting the battery.   Complete System Reset   BLE is a fickle beast. If at any point it is impossible to discover or connect to the camera, perform the following.      Reset the camera by choosing Connections ‚Äì&gt; Reset Connections        Power cycle the bluetooth adapter:        [bluetooth]# power off  Changing power off succeeded  [CHG] Controller FC:44:82:DD:5A:3F Powered: no  [CHG] Controller FC:44:82:DD:5A:3F Discovering: no  [CHG] Controller FC:44:82:DD:5A:3F Class: 0x00000000  [bluetooth]# power on  [CHG] Controller FC:44:82:DD:5A:3F Class: 0x002c010c  Changing power on succeeded  [CHG] Controller FC:44:82:DD:5A:3F Powered: yes                Remove the GoPro from the paired devices:        [bluetooth]# paired-devices  Device DF:34:ED:D1:DA:E8 GoPro 0456  [bluetooth]# remove DF:34:ED:D1:DA:E8           Restart the procedure detailed above   Logs   It is also possible to get some bluetooth system logs.   To enable debug information and view HCI Trace information from the Bluetooth Monitor:   sudo sed -i 's/bluetoothd/bluetoothd \\-d/g' /lib/systemd/system/bluetooth.service sudo btmon   To view the DBus log (i.e. to see BlueZ messages):   sudo dbus-monitor --system   You can search this for ‚Äúbluez‚Äù but not every relevant Bluetooth message will include it.  ","categories": [],
        "tags": [],
        "url": "/tutorials/bash/bluez",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "GoPro C++ Demo",
        "excerpt":"This folder contains C and C++ examples to perform some Open GoPro functionality. There are three examples, each of which are detailed in a section below.      media commands   stream commands   UI control commands   Requirements   To build these demos as is, libCurl and cJSON are necessary. libCurl is a client-side URL transfer library. This is used to make command requests to the camera over WiFi and get the JSON response. cJSON is an ultra-light JSON parser that can be used to parse the JSON responses from the WiFi commands. Both can be used in either C or C++ and work for MacOS, Linux and Windows.   To connect to the camera:      Connect BLE to turn on AP and get WiFi SSID/PASSPHRASE   Use retrieved WiFi SSID/PASSPHRASE to connect system to GoPro WiFi   Media Commands   This demo demonstrates one way to get the media list and download the first media file. It also supports requests to get the media list, media info and downloading specific media files.   Media List:   $ ./bin/media_commands &lt;-l, --list_files&gt;   Media List(Pretty Print):   $ ./bin/media_commands &lt;-f, --list_files_pretty&gt;   Media Info:   $ ./bin/media_commands &lt;-i, --info&gt; &lt;camera_file_path&gt;   Media Info(Pretty Print):   $ ./bin/media_commands &lt;-p, --info_pretty&gt; &lt;camera_file_path&gt;   Media Download:   $ ./bin/media_commands &lt;-g, --download &lt;camera_file_path&gt; &lt;output_path/output_file_name&gt;&gt;   Media Demo:   $ ./bin/media_commands &lt;-d, --demo&gt; &lt;output_path&gt;   Stream Commands   This demo demonstrates one way to start and stop the preview stream.      Note: To run the Preview Stream demo. A media player (i.e: VLC) that supports UDP is needed to view the preview stream. The UDP address is udp://0.0.0.0:8554    Start Stream:   $ ./bin/stream_commands &lt;-s, --start&gt;   Stop Stream:   $ ./bin/stream_commands &lt;-e, --end&gt;   Preview Stream Demo:   $ ./bin/stream_commands &lt;-d, --demo&gt;   UI Control Commands   This demo shows one example of setting a setting value (video resolution).   Set resolution:   $ ./bin/ui_control_commands  ","categories": [],
        "tags": [],
        "url": "/demos/c_c++/GoProC++Demo",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "GoProCSharpSample",
        "excerpt":"This sample demonstrates how to discover, pair, and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the code shows how to:      Enable Wi-Fi on the GoPro camera   Read the camera wifi name and password   Get status and notification of camera‚Äôs battery level, encoding flag, and wifi ap on flag.   Start and stop camera shutter   Requirements   Visual Studio is required to run the solution. Visit https://visualstudio.microsoft.com/downloads/ to download.   The target .NET framework is v4.7.2   GoPro camera must be paired before any other operations will succeed. Put the camera in pairing mode before attempting pairing with the app.   Usage      Open and run the demo in Visual Studio to show the GUI   Scan for GoPro devices   Pair to the discovered device that is not GoPro Cam. In the .gif below, this is GoPro 0456 (Only needs to be done once, or if camera is factory reset)   After pairing is successful, connect to the same GoPro device   Now use any of the GUI buttons to read WiFi info, enable WiFi AP, set shutter, etc.     ","categories": [],
        "tags": [],
        "url": "/demos/csharp/GoProCSharpSample",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Open GoPro Python SDK",
        "excerpt":"        TODO add PyPi badge once released on PyPi   This is a Python package that provides an interface for the user to exercise the Open GoPro Bluetooth Low Energy (BLE) and Wi-Fi API‚Äôs as well as install command line interfaces to take photos, videos, and view the preview stream.      Free software: MIT license   Documentation: TODO Add link   View on Github: https://github.com/gopro/OpenGoPro/tree/main/demos/python/sdk_wireless_camera_control   Documentation   This README is an overview of the package. Complete documentation can be found on Open GoPro: TODO ADD LINK.   Installation       $ pip install open_gopro   Features      Top-level GoPro class interface to use both BLE / WiFi   Cross-platform (tested on MacOS Big Sur, Windows 10, and Ubuntu 20.04)            BLE implemented using bleak &lt;https://pypi.org/project/bleak/&gt;_       Wi-Fi controller provided in the Open GoPro package (loosely based on the Wireless Library &lt;https://pypi.org/project/wireless/&gt;_ )           Supports all Open GoPro API's &lt;https://github.com/gopro/OpenGoPro&gt;_   Automatically handles some required functionality:            manage camera ready / encoding       periodically sends keep alive signals           Includes demo scripts installed as command-line applications to show BLE and WiFi functionality   Usage   To automatically connect to GoPro device via BLE and WiFI, take a video, and download all files:   from open_gopro import GoProBLE, params  with GoPro() as gopro:     gopro.ble_command.load_preset(params.Preset.CINEMATIC)     gopro.ble_setting.resolution.set(params.Resolution.RES_5k)     gopro.ble_setting.fps.set(params.FPS.FPS_30)     gopro.ble_command.set_shutter(params.Shutter.ON)     time.sleep(2) # Record for 2 seconds     gopro.ble_command.set_shutter(params.Shutter.OFF)      # Download all of the files from the camera     media_list = [x[\"n\"] for x in gopro.wifi_command.get_media_list()[\"media\"][0][\"fs\"]]     for file in media_list:         gopro.wifi_command.download_file(camera_file=file)   And much more!   Demos      Note! These demos can be found on Github    Demos can be found in the installed package in the ‚Äúdemos‚Äù folder. They are installed as a CLI entrypoint and can be run via:   $ gopro-photo   $ gopro-video   $ gopro-stream   For more information on each, try running with help as such:   $ gopro-photo --help  usage: gopro-photo [-h] [-i IDENTIFIER] [-l LOG] [-o OUTPUT]  Connect to a GoPro camera, take a photo, then download it.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to   -l LOG, --log LOG     Location to store detailed log   -o OUTPUT, --output OUTPUT                         Where to write the photo to. If not set, write to 'photo.jpg'  ","categories": [],
        "tags": [],
        "url": "/demos/python/sdk_wireless_camera_control",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Swift Enable WiFi Demo",
        "excerpt":"This demo demonstrates how to discover and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the demo demonstrates how to enable Wi-Fi on the GoPro camera and join the camera‚Äôs Wi-Fi. The steps required to join camera‚Äôs Wi-Fi are:      Enable Wi-Fi   Request camera‚Äôs Wi-Fi settings (SSID and password)   Use iOS NetworkExtension API to join camera‚Äôs WiFi   Requirements   GoPro camera must be paired with the mobile device. If the camera is not paired, put the camera in pairing mode   File Structure   BLE      CentralManager.swift - A simple wrapper around CBCentralManager to handle CoreBluetooth Central related tasks   Peripheral.swift - A simple wrapper around CBPeripheral to handle CoreBluetooth Peripheral related tasks   Peripheral+Camera.swift - An extension of Peripheral class for sending commands to a GoPro camera   Views      CameraSelectionView.swift - A SwiftUI list view for showing the nearby GoPro cameras   CameraView.swift - A simple view with a button for initiate the request to enable Wi-Fi on the connected GoPro camera  ","categories": [],
        "tags": [],
        "url": "/demos/swift/EnableWiFiDemo",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 1: Connect BLE",
        "excerpt":"This tutorial will provide a walk-through to connect to the GoPro camera via BLE using bleak.   Requirements   Hardware           One of the following systems:              Windows 10, version 16299 (Fall Creators Update) or greater       Linux distribution with BlueZ &gt;= 5.43       OS X/macOS support via Core Bluetooth API, from at least OS X version 10.11                A GoPro camera that is supported by Open GoPro       Software   Python      Python 3.8.x must be installed. See this Python installation guide.   Tutorials Package   This set of tutorials is accompanied by a Python package consisting of scripts (separated by tutorial module). These can be found on Github. Once the Github repo has been cloned or downloaded to your local machine, the package can be installed as follows:      Enter the python tutorials directory at $INSTALL/tutorials/python/ where $INSTALL is the top level of the Open GoPro repo where it exists on your local machine   Use pip to install the requirements file:   pip install -r requirements.txt      This will also install the Open GoPro Python SDK which will be used for some of the optional examples through these tutorials.    You can test that installation was successful by viewing the installed package‚Äôs information:   $ pip show open-gopro-bleak-tutorials Name: open-gopro-bleak-tutorials Version: 0.0.1 Summary: Open GoPro Bleak Tutorials Home-page: https://github.com/gopro/OpenGoPro Author: GoPro Author-email: gopro.com License: MIT Location: c:\\gopro\\opengopro\\tutorials\\python\\bleak Requires: bleak Required-by:   The scripts that will be used for this tutorial can be found at in the Tutorial 1 Folder.   Basic BLE Tutorial   This tutorial will walk through the process of connecting to the GoPro via Bluetooth Low Energy (BLE). It is basically just an explanation of the ble_connect.py. This same connect functionality will be used as a foundation for all future BLE tutorials.   Here is a summary of the sequence that will be described in detail in the following sections:      Just Show me the Demo!!   If you just want to run the demo, you can do:   python ble_connect.py     Python 3.8.x must be used as specified in the requirements  See the help for parameter definition:   $ python ble_connect.py --help usage: ble_connect.py [-h] [-i IDENTIFIER]  Connect to a GoPro camera, pair, then enable notifications.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to   Asyncio   The bleak module is based on asyncio which means that its awaitable functions need to be called from an async coroutine. In order to do this, all of the code below should be running in an async function. We accomplish this in the tutorial scripts by making main async as such:   import asyncio  async def main():     # Put our code here  if __name__ == \"__main__\":     asyncio.run(main())   Advertise   First, we need to ensure the camera is discoverable (i.e. it is advertising). Ensure that the Camera is powered on, then select Connections ‚Äì&gt; Connect Device ‚Äì&gt; Quik App   The screen should appear as such:                     Camera is discoverable.            Scan                                               code                                                     output                                                                Next, we must find the GoPro Camera using bleak. Let‚Äôs initialize an empty dict that will store discovered devices, indexed by name:   # Map of devices indexed by name devices: Dict[str, BleakDevice] = {}   We‚Äôre then going to scan for all devices. We are passing a scan callback to bleak in order to also find non-connectable scan responses. We are keeping any devices that have a device name.   # Scan callback to also catch nonconnectable scan responses def _scan_callback(device: BleakDevice, _: Any) -&gt; None:     # Add to the dict if not unknown     if device.name != \"Unknown\" and device.name is not None:         devices[device.name] = device  # Now discover and add connectable advertisements for device in await BleakScanner.discover(timeout=5, detection_callback=_scan_callback):     if device.name != \"Unknown\" and device.name is not None:         devices[device.name] = device   Now we can search through the discovered devices to see if we found a GoPro. Any GoPro device name will be structured as GoPro XXXX where XXXX is the last four digits of your camera‚Äôs serial number.   First, we define a regex which is either ‚ÄúGoPro ‚Äú followed by any four digits if no identifier was passed, or ‚ÄúGoPro ‚Äú concatenated with the identifier if it exists. In the demo ble_connect.py, the identifier is taken from the command-line arguments.   token = re.compile(r\"GoPro \\d\\d\\d\\d\" if identifier is None else f\"GoPro {identifier}\")   Now we build a list of matched devices by checking if each device‚Äôs name includes the token regex.   matched_devices: List[BleakDevice] = [] # Now look for our matching device(s) matched_devices = [device for name, device in devices.items() if token.match(name)]   Due to potential RF interference and the asynchronous nature of BLE advertising / scanning, it is possible that the advertising GoPro will not be discovered by the scanning PC in one scan. Therefore, you may need to redo the scan (as ble_connect.py does) until a GoPro is found. That is, matched_device must contain at least one device.   When running the demo, discovered devices will be logged to the console as they are found. Click the output tab to see an example of this.                          Here is an example of the log from `ble_connect.py` of scanning for devices. Note that this includes several rescans until the devices was found.  $ python ble_connect.py INFO:root:Scanning for bluetooth devices... INFO:root:      Discovered: INFO:root:      Discovered: TR8600 seri INFO:root:Found 0 matching devices. INFO:root:      Discovered: INFO:root:      Discovered: TR8600 seri INFO:root:      Discovered: GoPro Cam INFO:root:      Discovered: GoPro 0456 INFO:root:Found 1 matching devices.   Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera‚Äôs serial number.                    Connect                                               code                                                     output                                                                Now that we have discovered at least one GoPro device to connect to, the next step is to establish a BLE connection to the camera as such:   # We're just taking the first device if there are multiple. device = matched_devices[0] client = BleakClient(device) await client.connect(timeout=15)   Click the output tab to see an example of what the log from ble_connect.py will show.                          INFO:root:Establishing BLE connection to EF:5A:F6:13:E6:5A: GoPro 0456... INFO:bleak.backends.dotnet.client:Services resolved for BleakClientDotNet (EF:5A:F6:13:E6:5A) INFO:root:BLE Connected!   Here we can see that the connection has successfully been established as well as the GoPro‚Äôs BLE MAC address.                    Pair   The GoPro has encryption-protected characteristics which require us to pair before writing to them. Therefore now that we are connected, we need to attempt to pair:   try:     await client.pair() except NotImplementedError:     # This is expected on Mac     pass   Not all OS‚Äôs allow pairing but some require it. Rather than checking for the OS, we are just catching the exception when it fails.   Once paired, the camera should beep and display ‚ÄúConnection Successful‚Äù.     It is now no longer necessary to pair on subsequent connections.  Enable Notifications                                               enable                                                     output                                                                As specified in the Open GoPro Bluetooth API, we must enable notifications for a given characteristic to receive responses from it.     It is necessary to define a notification handler to pass to the bleak `start_notify` method. Since we only care about connecting to the device in this tutorial (and not actually receiving data), we are just passing an empty function. A future tutorial will demonstrate how to use this meaningfully.  To enable notifications, we loop over each characteristic in each service and enable the characteristic for notification if it has notify properties:   for service in client.services:     for char in service.characteristics:         if \"notify\" in char.properties:             await client.start_notify(char, notification_handler)   Go to the next tab to see the log output.                          Here we can see that notifications are enabled for each characteristic that is notifiable.   INFO:root:Enabling notifications... INFO:root:Enabling notification on char 00002a19-0000-1000-8000-00805f9b34fb INFO:root:Enabling notification on char b5f90073-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90075-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90077-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90079-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90092-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90081-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90083-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90084-aa8d-11e3-9046-0002a5d5c51b INFO:root:Done enabling notifications   The characteristics that correspond to each UUID listed in the log can be found in the Open GoPro API. These will be used in a future tutorial to send data.                    Quiz time! üìö ‚úèÔ∏è                 How often is it necessary to pair?                               A: Pairing must occur every time to ensure safe BLE communication.                                    B: We never need to pair as the GoPro does not require it to communicate.                                    C: Pairing only needs to occur once as the keys will be automatically re-used for future connections.                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         Pairing is only needed once (assuming neither side deletes the keys). If the     GoPro deletes the keys (via Connections-&gt;Reset Connections), the devices will need to re-pair.        Troubleshooting   Complete System Reset   BLE is a fickle beast. If at any point it is impossible to discover or connect to the camera, perform the following.      Reset the camera by choosing Connections ‚Äì&gt; Reset Connections   Use your OS‚Äôs bluetooth settings GUI to remove / unpair the Gopro   Restart the procedure detailed above   Logs   The demo program has enabled bleak logs and is also using the default python logging module to write its own logs.   To enable more bleak logs, follow bleak‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You can now successfully connect to the GoPro via BLE and prepare it to receive / send data. To see how to send commands, you should advance to the next tutorial.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/connect-ble",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 2: Send BLE Commands",
        "excerpt":"This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to send commands and receive responses.   Commands in this sense are specifically procedures that are initiated by either:      Writing to the Command Request UUID and receiving responses via the Command Response UUID. They are listed here.   Writing to the Setting UUID and receiving responses via the Setting Response UUID. They are listed here.      It is required that you have first completed the connect tutorial before going through this tutorial.    This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab.   Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 2 Folder.   Just Show me the Demo(s)!!   Each of the commands detailed in [Sending Commands] has a corresponding script to demo it. If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python ble_command_set_shutter.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   $ python ./ble_command_set_shutter.py --help usage: ble_command_set_shutter.py [-h] [-i IDENTIFIER]  Connect to a GoPro camera, set the shutter on, wait 2 seconds, then set the shutter off.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to   Setup   We must first connect as was discussed in the connect tutorial. In this case, however, we are defining a meaningful (albeit naive) notification handler that will:      print byte data and handle that the notification was received on   check if the response is what we expected   set an event to notify the writer that the response was received   This is a very simple handler: response parsing will be expanded upon in the next tutorial.   def notification_handler(handle: int, data: bytes) -&gt; None:     logger.info(f'Received response at {handle=}: {hexlify(data, \":\")}')      # If this is the correct handle and the status is success, the command was a success     if client.services.characteristics[handle].uuid == response_uuid and data[2] == 0x00:         logger.info(\"Command sent successfully\")     # Anything else is unexpected. This shouldn't happen     else:         logger.error(\"Unexpected response\")      # Notify the writer     event.set()   The event used above is a simple synchronization event that is only alerting the writer that a notification was received. There is much more to the synchronization and data parsing than this but this will be discussed in future tutorials. For now, we‚Äôre just checking that the handle matches what is expected and that the status (third byte) is success (0x00).   Command Overview   Both Command Requests and Setting Requests follow the same procedure:      Write to relevant request UUID   Receive confirmation from GoPro (via notification from relevant response UUID) that request was received.   GoPro reacts to command      Note! The notification response only indicates that the request was received and whether it was accepted or rejected. The relevant behavior of the GoPro must be observed to verify when the command‚Äôs effects have been applied.    Here is the procedure from power-on to finish:      Sending Commands   Now that we are are connected, paired, and have enabled notifications (using our defined callback), we can send commands.   First, we need to define the attributes to write to and receive responses from, which, for commands, are the ‚ÄúCommand Request‚Äù characteristic (UUID b5f90072-aa8d-11e3-9046-0002a5d5c51b) and ‚ÄúCommand Response‚Äù characteristic (UUID b5f90073-aa8d-11e3-9046-0002a5d5c51b).   COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") COMMAND_RSP_UUID = GOPRO_BASE_UUID.format(\"0073\")   Or, for settings, the ‚ÄúSettings‚Äù characteristic (UUID b5f90074-aa8d-11e3-9046-0002a5d5c51b) and ‚ÄúSettings Response‚Äù (UUID b5f90075-aa8d-11e3-9046-0002a5d5c51b).   SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\")     We're using the GOPRO_BASE_UUID string imported from the module's `__init__.py ` to build these.  Set Shutter   The first command we will be sending is Set Shutter, which at byte level is:                  Command       Bytes                       Set Shutter Off       0x03 0x01 0x01 0x00                 Set Shutter On       0x03 0x01 0x01 0x01                                                       Set Shutter On                                                     Set Shutter Off                                                                Now, let‚Äôs write the bytes to the ‚ÄúCommand Request‚Äù UUID to turn the shutter on and start encoding!   event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 1])) await event.wait() # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep and it will either take a picture or start recording depending on what mode it is in.   Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications. This can be seen in the demo log:   INFO:root:Setting the shutter on INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   If you are recording a video, go to the next tab to set the shutter off.                          We can now set the shutter off:      We‚Äôre waiting 2 seconds in case you are in video mode so that we can capture a 2 second video.    time.sleep(2) event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 0])) await event.wait() # Wait to receive the notification response   This will log in the console as follows:   INFO:root:Setting the shutter off INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully                    Sleep   The next command we will be sending is Sleep, which at byte level is:                  Command       Bytes                       Sleep       0x01 0x05           Now, let‚Äôs write the bytes to the ‚ÄúCommand Request‚Äù UUID to put the camera to sleep!   event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x05])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep display a spinner showing ‚ÄúPowering Off‚Äù   Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Putting the camera to sleep INFO:root:Received response at handle=52: b'02:05:00' INFO:root: Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   Since the camera has gone to sleep, it must be reconnected to via BLE to communicate again as detailed in the connect tutorial.   Load Preset Group   The next command we will be sending is Load Preset Group, which is used to toggle between the 3 groups of presets (video, photo, and timelapse). At byte level, the commands are:                  Command       Bytes                       Load Video Preset Group       0x04 0x3E 0x02 0x03 0xE8                 Load Photo Preset Group       0x04 0x3E 0x02 0x03 0xE9                 Load Timelapse Preset Group       0x04 0x3E 0x02 0x03 0xEA           Now, let‚Äôs write the bytes to the ‚ÄúCommand Request‚Äù UUID to change the preset group to Video!   event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x04, 0x3E, 0x02, 0x03, 0xE8])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep and move to the Video Preset Group. You can tell this by the logo at the top middle of the screen:                     Load Preset Group            Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   Load Preset   The next command we will be sending is Load Preset, which is used to select a specific preset that is part of a Preset Group. At byte level, some of the commands for the various preset are:                  Command       Bytes                       Load Cinematic Preset       0x06 0x40 0x04 0x00 0x00 0x00 0x02                 Load Slo-Mo Preset       0x06 0x40 0x04 0x00 0x00 0x00 0x03                 Load Burst Photo Preset       0x06 0x40 0x04 0x00 0x01 0x00 0x02                 Load Night Photo Preset       0x06 0x40 0x04 0x00 0x01 0x00 0x03              Note! It is possible that the preset ID values will vary in future cameras. The only absolutely correct way to know the preset ID is to read them from the ‚ÄúGet Preset Status‚Äù protobuf command. A future lab will discuss protobuf commands.    Now, let‚Äôs write the bytes to the ‚ÄúCommand Request‚Äù UUID to change the preset to Cinematic!       event.clear()     await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x02]))     await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep and switch to the Cinematic Preset (assuming it wasn‚Äôt already sent). You can verify this by seeing the preset name in the pill at bottom middle of the screen.                     Load Preset            Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Loading the cinematic preset... INFO:root:Received response at handle=52: b'02:40:00' INFO:root:Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   Enable Analytics   The next command we will be sending is Enable Analytics, which at byte level is:                  Command       Bytes                       Enable Analytics       0x01 0x50           This command is used to notify that a Third Party is using the Open GoPro API. It should be called after each connection.  The use of this command by third parties will help improve Open GoPro.   Now, let‚Äôs write the bytes to the ‚ÄúCommand Request‚Äù UUID to enable analytics.   event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x50])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Enabling analytics... INFO:root:Received response at handle=52: b'02:50:00' INFO:root:Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   Set the Video Resolution   The next command we will be sending is Set Video Resolution. This is used to change the value of the Video Resolution setting. It is important to note that this only affects video resolution (not photo). Therefore, the Video Preset Group must be active in order for it to succeed. This can be done either manually through the camera UI or by sending [Load Preset Group].      Additionally, this resolution it only affects the current video preset. Each video preset can have its own independent values for video resolution.    Here are some of the byte level commands for various video resolutions.                  Command       Bytes                       Set Video Resolution to 1080       0x03 0x02 0x01 0x09                 Set Video Resolution to 2.7K       0x03 0x02 0x01 0x04                 Set Video Resolution to 4K       0x03 0x02 0x01 0x18           Now, let‚Äôs write the bytes to the ‚ÄúSetting Request‚Äù UUID to change the video resolution to 1080!   event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x02, 0x01, 0x09])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep and see the video resolution change to 1080 in the pill in the bottom-middle of the screen:                     Set Video Resolution            Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù. If the Preset Group was not Video, the status will not be success.   Set the Frames Per Second (FPS)   The next command we will be sending is Set FPS. This is used to change the value of the FPS setting. It is important to note that this setting is dependent on the video resolution. That is, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Also, the current anti-flicker value may further limit possible FPS values. Check the camera capabilities  to see which FPS values are valid for given use cases.   Therefore, for this step of the tutorial, it is assumed that the resolution has been set to 1080 as in [Set the Video Resolution].   Here are some of the byte level commands for various FPS values.                  Command       Bytes                       Set FPS to 24       0x03 0x03 0x01 0x0A                 Set FPS to 60       0x03 0x03 0x01 0x05                 Set FPS to 240       0x03 0x03 0x01 0x00           Now, let‚Äôs write the bytes to the ‚ÄúSetting Request‚Äù UUID to change the FPS to 240!   event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x03, 0x01, 0x00])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  You should hear the camera beep and see the FPS change to 240 in the pill in the bottom-middle of the screen:                     Set FPS            Also note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log:   INFO:root:Setting the fps to 240 INFO:root:Received response at handle=57: b'02:03:00' INFO:root:Command sent successfully   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù. If the video resolution was higher, for example 5K, this would fail.   Quiz time! üìö ‚úèÔ∏è                 Which of the following is not a real preset group?                               A: Timelapse                                    B: Photo                                    C: Burst                                    D: Video                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         There are 3 preset groups (Timelapse, Photo, and Video). These can be     set via the Load Preset Group command.                      What of the following sets of FPS values are possible at 5K?                               A: [24, 25, 30]                                    B: [24, 25, 30, 60]                                    C: [24, 25, 30, 60, 120]                                    D: Any FPS is valid in at 5k                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         Among these options, only 24 is possible. You're not actually expected to know     this. But you should know where to find the information: https://github.com/gopro/OpenGoPro/tree/main/docs/ble#camera-capabilities        Troubleshooting   See the first tutorial‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You can now send any of the other BLE commands detailed in the Open GoPro documentation in a similar manner.   To see how to parse more complicate responses, proceed to the next tutorial.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/send-ble-commands",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 3: Parse BLE TLV Responses",
        "excerpt":"This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to parse BLE Type-Length-Value (TLV) Responses.   Besides TLV, some BLE commands instead return protobuf responses. These will be discussed in a future tutorial.      Note! It is required that you have first completed the connect and sending commands tutorials before going through this tutorial.    This tutorial will give an overview of types of responses, then give examples of parsing each type before finally providing a Response class that will be used in future tutorials.   Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 3 Folder.   Just Show me the Demo(s)!!   Each of the examples described below has a corresponding script to demo it. If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python ble_command_get_state.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   $ python ./ble_command_get_state.py --help usage: ble_command_get_state.py [-h] [-i IDENTIFIER]  Connect to a GoPro camera via BLE, then get its statuses and settings.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to   Setup   We must first connect as was discussed in the connect tutorial. When enabling notifications, one of the notification handlers described in the following sections will be used.   Response Overview   In the preceding tutorials, we have been using a very simple response handling procedure where the notification handler simply checks that the UUID is the expected UUID and that the status byte of the response is 0 (Success). This has been fine since we were only sending specific commands where this works and we know that the sequence always appears as such (connection sequence left out for brevity):      In actuality, responses can be more complicated. As described in the Open GoPro Interface, responses can be be comprised of multiple packets where each packet is &lt;= 20 bytes such as:      This requires the implementation of accumulating and parsing algorithms which will be described in [Parsing Multiple Packet TLV Responses].   Parsing a One Packet TLV Response   This section will describe how to parse one packet (&lt;= 20 byte) responses. A one-packet response is formatted as such:                  Header (length)       Command / Setting ID       Status       Response                       1 byte       1 byte       1 bytes       Length - 2 bytes           Command / Setting Responses with Response Length 0   These are the only responses that we have seen thus far through the first 2 tutorials. They return a status but have a 0 length additional response. For example, consider Set Shutter. It returned a response of   02:01:00   This equates to:                  Header (length)       Command / Setting / Status ID       Status       Response                       1 byte       1 byte       1 bytes       Length - 2 bytes                 0x02       0x01 == Set Shutter       0x00 == Success       (2 -2 = 0 bytes)           We can see how this response includes the status but no additional response data. This type of response will be used for most Commands and Setting Responses as seen in the previous tutorial.   Complex Command Response   There are some commands that do return additional response data. These are called ‚Äúcomplex responses.‚Äù From the commands reference, we can see that these are:      Get Open GoPro Version (ID == 0x51)   Get Hardware Info (ID == 0x3C)   The ble_command_get_version.py script demonstrates a simple parser for the Open GoPro Get Version command which we will walk through here.   First, we send the command to the Command Request UUID:   COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x51])) await event.wait()  # Wait to receive the notification response      Note! The following snippets of code are taken from the notification handler    We then receive a response at the expected handle. This is logged as:   INFO:root:Getting the Getting the Open GoPro version... INFO:root:Received response at handle=52: b'06:51:00:01:01:01:00'   This equates to:                  Header (length)       Command / Setting / Status ID       Status       Response                       1 byte       1 byte       1 bytes       Length - 2 bytes                 0x06       0x51 == Get Version       0x00 == Success       0x01 0x01 0x01 0x00           We can see that this ‚Äúcomplex response‚Äù contains 4 additional bytes that need to be parsed. Using the information from the interface description, we know to parse this as:                  Byte       Meaning                       0x01       Length of Major Version Number                 0x01       Major Version Number                 0x01       Length of Minor Version Number                 0x00       Minor Version Number           We implement this in the notification handler as follows. First, we parse the length, command ID, and status from the first 3 bytes of the response:   len = data[0] command_id = data[1] status = data[2]   Next we parse the remaining four bytes of the response as individual values formatted as such:                  Length       Value                       1 byte       Length bytes           index = 3 params = [] while index &lt;= len:     param_len = data[index]     index += 1     params.append(data[index : index + param_len])     index += param_len   From the complex response definition, we know these parameters equate to the major and the minor version so let‚Äôs print them (and all of the other response information) as such:   major, minor = params logger.info(f\"Received a response to {command_id=} with {status=}: version={major[0]}.{minor[0]}\")   which shows on the log as:   INFO:root:Received a response to command_id=81 with status=0: version=1.0   Quiz time! üìö ‚úèÔ∏è                 What is the maximum size of an individual notification response packet?                               A: 20 bytes                                    B: 256 bytes                                    C: There is no maximum size                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         Responses can be composed of multiple packets where each packet is at     maximum 20 bytes.                      What is the maximum amount of packets that one response can be composed of?                               A: 20 bytes                                    B: 256 bytes                                    C: There is no maximum size                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         There is no limit on the amount of packets that can comprise a response.                      What is the maximum amount of packets that one response can be composed of?                               A: Always 1 packet                                    B: Always multiple packets.                                    C: Always 1 packet except for complex responses.                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         Command responses are almost always 1 packet (just returning the status).     The exception are complex responses which can be multiple packets (in the case of Get Hardware     Info)                      How many packets are setting responses comprised of?                               A: Always 1 packet                                    B: Always multiple packets.                                    C: Always 1 packet except for complex responses.                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         Settings Responses only ever contain the command status. Furthermore, there     is no concept of complex responses for setting commands.        Parsing Multiple Packet TLV Responses   This section will describe parsing TLV responses that contain more than one packet. It will first describe how to accumulate such responses and then provide a parsing example. The example script that will be walked through for this section is ble_command_get_state.py. We will be creating a small Response class that will be re-used for future tutorials.   Accumulating the Response   The first step is to accumulate the multiple packets into one response. Whereas for all tutorials until now, we have just used the header bytes of the response as the length, we now must completely parse the header as it is defined:                    Byte 1         Byte 2 (optional)         Byte 3 (optional)                   7         6         5         4         3         2         1         0         7         6         5         4         3         2         1         0         7         6         5         4         3         2         1         0                   0: Start         00: General         Message Length: 5 bits                            0: Start         01: Extended (13-bit)         Message Length: 13 bits                            0: Start         10: Extended (16-bit)                  Message Length: 16 bits                   0: Start         11: Reserved                            1: Continuation                    The basic algorithm here (which is implemented in the Message.accumulate method) is as follows:           Continuation bit set?       if buf[0] &amp; CONT_MASK:     buf.pop(0) else:     ...           No, continuation bit was not set. So create new response, then get its length.       # This is a new packet so start with an empty byte array self.bytes = bytearray() hdr = Header((buf[0] &amp; HDR_MASK) &gt;&gt; 5) if hdr is Header.GENERAL:     self.bytes_remaining = buf[0] &amp; GEN_LEN_MASK     buf = buf[1:] elif hdr is Header.EXT_13:     self.bytes_remaining = ((buf[0] &amp; EXT_13_BYTE0_MASK) &lt;&lt; 8) + buf[1]     buf = buf[2:] elif hdr is Header.EXT_16:     self.bytes_remaining = (buf[1] &lt;&lt; 8) + buf[2]     buf = buf[3:]           Append current packet to response and decrement bytes remaining.       # Append payload to buffer and update remaining / complete self.bytes.extend(buf) self.bytes_remaining -= len(buf)           In the notification handler, we are then parsing if there are no bytes remaining.           if response.is_received:         response.parse()                             We can see this in action when we send the Get All Setting Values Query.     Queries aren't introduced until the next tutorial so for now, just pay attention to the response.  We send the command as such:   QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x01, 0x12])) await event.wait()  # Wait to receive the notification response   Then, in the notification handler, we continuously receive and accumulate packets until we have received the entire response, at which point we notify the writer that the response is ready:    def notification_handler(handle: int, data: bytes) -&gt; None:         response.accumulate(data)          if response.is_received:             response.parse()              # Notify writer that procedure is complete             event.set()     We also first parse the response but that will be described in the next section.  We can see the individual packets being accumulated in the log:   INFO:root:Getting the camera's settings... INFO:root:Received response at handle=62: b'21:25:12:00:02:01:09:03:01:01:05:0 INFO:root:self.bytes_remaining=275 INFO:root:Received response at handle=62: b'80:01:00:18:01:00:1e:04:00:00:00:0 INFO:root:self.bytes_remaining=256 INFO:root:Received response at handle=62: b'81:0a:25:01:00:29:01:09:2a:01:05:2 INFO:root:self.bytes_remaining=237 INFO:root:Received response at handle=62: b'82:2f:01:04:30:01:03:36:01:00:3b:0 INFO:root:self.bytes_remaining=218 INFO:root:Received response at handle=62: b'83:04:00:00:00:00:3e:04:00:00:00:0 INFO:root:self.bytes_remaining=199 INFO:root:Received response at handle=62: b'84:00:42:04:00:00:00:00:43:04:00:0 INFO:root:self.bytes_remaining=180 INFO:root:Received response at handle=62: b'85:4f:01:00:53:01:00:54:01:00:55:0 INFO:root:self.bytes_remaining=161 INFO:root:Received response at handle=62: b'86:01:28:5b:01:02:60:01:00:66:01:0 INFO:root:self.bytes_remaining=142 INFO:root:Received response at handle=62: b'87:00:6a:01:00:6f:01:0a:70:01:ff:7 INFO:root:self.bytes_remaining=123 INFO:root:Received response at handle=62: b'88:75:01:00:76:01:04:79:01:00:7a:0 INFO:root:self.bytes_remaining=104 INFO:root:Received response at handle=62: b'89:01:00:7e:01:00:80:01:0c:81:01:0 INFO:root:self.bytes_remaining=85 INFO:root:Received response at handle=62: b'8a:0c:85:01:09:86:01:00:87:01:01:8 INFO:root:self.bytes_remaining=66 INFO:root:Received response at handle=62: b'8b:92:01:00:93:01:00:94:01:02:95:0 INFO:root:self.bytes_remaining=47 INFO:root:Received response at handle=62: b'8c:01:00:9c:01:00:9d:01:00:9e:01:0 INFO:root:self.bytes_remaining=28 INFO:root:Received response at handle=62: b'8d:00:a2:01:00:a3:01:01:a4:01:00:a INFO:root:self.bytes_remaining=9 INFO:root:Received response at handle=62: b'8e:a8:04:00:00:00:00:a9:01:01' INFO:root:self.bytes_remaining=0 INFO:root:Successfully received the response   At this point the response has been accumulated. See the next section for how to parse it.   Quiz time! üìö ‚úèÔ∏è                 Which of the following is not a real preset group?                               A: The stop bit will be set in the header                                    B: The response has accumulated length bytes                                    C: By checking for the end of frame (EOF) sentinel character                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is B.         The length of the entire response is parsed from the first packet. We         then accumulate packets, keeping track of the received length, until all of the bytes         have been received. A and C are just made up üòú.        Query Responses   This section is going to describe responses to to BLE status / setting queries. We don‚Äôt actually introduce such queries until the next tutorial so for now, only the parsing of the response is important.     While multi-packet responses are almost always Query Responses, they can also be from Command Complex responses. In a real-world implementation, it is therefore necessary to check the received UUID to see how to parse.  Query Responses contain one or more TLV groups in their Response data. To recap, the generic response format is:                  Header (length)       Query ID       Status       Response                       1-2 bytes       1 byte       1 bytes       Length - 2 bytes           This means that query responses will contain an array of additional TLV groups in the ‚ÄúResponse‚Äù field as such:                  ID1       Length1       Value1       ID2       Length2       Value 2       ‚Ä¶       IDN       LengthN       ValueN                       1 byte       1 byte       Length1 bytes       1 byte       1 byte       Length2 bytes       ‚Ä¶       1 byte       1 byte       LengthN bytes           Depending on the amount of query results in the response, this response can be one or multiple packets. Therefore, we need to account for the possibility that it may always be more than 1 packet.   We can see an example of such parsing in the Response.parse method:            We have already parsed the length when we were accumulating the packet. So the next step is to parse the Query ID and Status:       self.id = self.bytes[0] self.status = self.bytes[1]           We then continuously parse Type (ID) - Length - Value groups until we have consumed the response. We are storing each value in a dict indexed by ID for later access.       buf = self.bytes[2:] while len(buf) &gt; 0:     # Get ID and Length     param_id = buf[0]     param_len = buf[1]     buf = buf[2:]     # Get the value     value = buf[:param_len]      # Store in dict for later access     self.data[param_id] = value      # Advance the buffer     buf = buf[param_len:]                              In the demo, we then log this entire dict after parsing is complete as such (abbreviated for brevity):   INFO:root:Received settings : {     \"2\": \"09\",     \"3\": \"01\",     \"5\": \"00\",     \"6\": \"01\",     \"13\": \"01\",     \"19\": \"00\",     \"30\": \"00:00:00:00\",     \"31\": \"00\",     \"32\": \"00:00:00:0a\",     \"41\": \"09\",     \"42\": \"05\",     \"43\": \"00\",     ...     \"153\": \"00\",     \"154\": \"01\",     \"155\": \"00\",     \"156\": \"00\",     \"157\": \"00\",     \"158\": \"01\",     \"159\": \"00\",     \"160\": \"00\",     \"161\": \"00\",     \"162\": \"00\",     \"163\": \"01\",     \"164\": \"00\",     \"165\": \"00\",     \"166\": \"00\",     \"167\": \"04\",     \"168\": \"00:00:00:00\",     \"169\": \"01\" }   We can see what each of these values mean by looking at the Open GoPro Interface.   For example:      ID 2 == 9 equates to Resolution == 1080   ID 3 == 1 equates to FPS == 120                 How many packets are query responses?                               A: Always 1 packet                                    B: Always multiple packets                                    C: Always 1 packet except for complex responses                                    D: Can be 1 or multiple packets                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is D.         Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries.                      Which field is not common to all responses?                               A: length                                    B: status                                    C: ID                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is D.         Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries.        Troubleshooting   See the first tutorial‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You can now parse any TLV response that is received from the GoPro, at least if it is received uninterrupted. There is additional logic required for a complete solution such as checking the UUID the response is received on and storing a dict of response per UUID. At the current time, this endeavor is left for the reader. For a complete example of this, see the Open GoPro Python SDK package.   To learn more about queries, go to the next tutorial.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/parse-ble-responses",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 4: BLE Queries",
        "excerpt":"This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to query the camera‚Äôs setting and status information via BLE.   ‚ÄúQueries‚Äù in this sense are specifically procedures that are initiated by writing to the Query UUID and receive responses via the Query Response UUID. This will be described in more detail below.      Note! It is required that you have first completed the connect, sending commands, and parsing responses tutorials before going through this tutorial.    This tutorial only considers sending these queries as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab.   Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 4 Folder.   Just Show me the Demo(s)!!   Each of the commands detailed in this tutorial has a corresponding script to demo it. If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python ble_query_poll_resolution_value.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   $ python ./ble_command_poll_resolution_value.py --help usage: ble_query_poll_resolution_value.py [-h] [-i IDENTIFIER]  Connect to a GoPro camera then get the current resolution.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to   Setup   We must first connect as was discussed in the connect tutorial.   We will also be using the Response class that was defined in the parsing responses tutorial to accumulate and parse notification responses to the Query Response characteristic. Throughout this tutorial, the query information that we will be reading is the Resolution Setting (ID 0x02). Therefore, we have slightly changed the notification handler to update a global resolution variable as it queries the resolution:   def notification_handler(handle: int, data: bytes) -&gt; None:     response.accumulate(data)      if response.is_received:         response.parse()          if client.services.characteristics[handle].uuid == QUERY_RSP_UUID:             resolution = Resolution(response.data[RESOLUTION_ID][0])          # Notify writer that the procedure is complete         event.set()   There are two methods to query status / setting information, each of which will be described in a following section:      Polling Query Information   Registering for query push notifications   Polling Query Information   It is possible to poll one or more setting / status values using the following commands.                  Query ID       Request       Query                       0x12       Get Setting value(s)       len:12:xx:xx                 0x13       Get Status value(s)       len:13:xx:xx           where xx are setting / status ID(s) and len is the total length of the query (not including the length). There will be specific examples below.     Since they are two separate commands, combination of settings / statuses can not be polled simultaneously.  Here is a generic sequence (the same is true for statuses):      The number of notification responses will vary depending on the amount of settings that have been queried. Note that setting values will be combined into one notification until it reaches the maximum notification size (20 bytes). At this point, a new response will be sent. Therefore, it is necessary to accumulate and then parse these responses as was described in parsing query responses   Individual Query Poll   Here we will walk through an example of polling one setting (Resolution) in ble_query_poll_resolution_value.py. First, we define the UUID‚Äôs to write to and receive from:   QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\")   Then we send the query command:   event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x12, RESOLUTION_ID])) await event.wait()  # Wait to receive the notification response   When the response is received in the notification handler, we update the global resolution variable:   def notification_handler(handle: int, data: bytes) -&gt; None:     response.accumulate(data)      # Notify the writer if we have received the entire response     if response.is_received:         response.parse()          # If this is query response, it must contain a resolution value         if client.services.characteristics[handle].uuid == QUERY_RSP_UUID:             resolution = Resolution(response.data[RESOLUTION_ID][0])   This all shows in the log as such:   INFO:root:Getting the current resolution INFO:root:Received response at handle=62: b'05:12:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_1080   For verification purposes, we are then changing the resolution and polling again to verify that the setting has changed:   INFO:root:Changing the resolution to Resolution.RES_1440... INFO:root:Received response at handle=57: b'02:02:00' INFO:root:self.bytes_remaining=0 INFO:root:Command sent successfully INFO:root:Polling the resolution to see if it has changed... INFO:root:Received response at handle=62: b'05:12:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_1440   Multiple Simultaneous Query Polls   Rather than just polling one setting, it is also possible to poll multiple settings. There is an example of this in ble_poll_multiple_setting_values.py. It is very similar to the previous example except for the following:   The query command now includes 3 settings:   RESOLUTION_ID = 2 FPS_ID = 3 FOV_ID = 121  await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x04, 0x12, RESOLUTION_ID, FPS_ID, FOV_ID]))     The length (first byte of the command) has been increased to 4 to accommodate the extra settings  We are also parsing the response to get all 3 values:   def notification_handler(handle: int, data: bytes) -&gt; None:     response.accumulate(data)      if response.is_received:         response.parse()          if client.services.characteristics[handle].uuid == QUERY_RSP_UUID:             resolution = Resolution(response.data[RESOLUTION_ID][0])             fps = FPS(response.data[FPS_ID][0])             video_fov = VideoFOV(response.data[FOV_ID][0])     When we are storing the updated setting, we are just taking the first byte (i..e index 0). A real-world implementation would need to know the length (and type) of the setting / status response by the ID. For example, sometimes settings / statuses are bytes, words, strings, etc.  They are then printed to the log which will look like the following:   INFO:root:Received response at handle=62: b'0b:12:00:02:01:07:03:01:01:79:01:00' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_1440 INFO:root:Video FOV is currently VideoFOV.FOV_WIDE INFO:root:FPS is currently FPS.FPS_120   Query All   It is also possible to query all settings / statuses by not passing any ID‚Äôs into the the query command, i.e.:                  Query ID       Request       Query                       0x12       Get All Settings       01:12                 0x13       Get All Statuses       01:13           An example of this can be seen in the ble_command_get_state.py script described in the parsing query responses tutorial   Quiz time! üìö ‚úèÔ∏è                 How can we poll the encoding status and the resolution setting using one command?                               A: Concatenate a Get Setting Value command and a Get Status command with the relevant ID's                                    B: Concatenate the Get All Setting and Get All Status commands.                                    C: It is not possible                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         It is not possible to concatenate commands. This would result in an unknown sequence of bytes         from the camera's perspective. So it is not possible to get a setting value and a status value in one command.         The Get Setting command (with resolution ID) and Get Status command(with encoding ID) must be sent sequentially         in order to get this information.        Registering for Query Push Notifications   Rather than polling the query information, it is also possible to use an interrupt scheme to register for push notifications when the relevant query information changes.   The relevant commands are:                  Query ID       Request       Query                       0x52       Register updates for setting(s)       len:52:xx:xx                 0x53       Register updates for status(es)       len:53:xx:xx                 0x72       Unregister updates for setting(s)       len:72:xx:xx                 0x73       Unregister updates for status(es)       len:73:xx:xx           where xx are setting / status ID(s) and len is the total length of the query (not including the length).   The Query ID‚Äôs for push notification responses are as follows:                  Query ID       Response                       0x92       Setting Value Push Notification                 0x93       Status Value Push Notification           Here is a generic sequence diagram of how this looks (the same is true for statuses):      That is, after registering for push notifications for a given query, notification responses will continuously be sent whenever the query changes until the client unregisters for push notifications for the given query.     The response to the Register command also contains the current setting / status value  We will walk through the ble_query_register_resolution_value_updates.py script to demonstrate this:   First, we define the UUID‚Äôs to write to and receive from:   SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\") QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\")   Then we register for updates when the resolution setting changes:   event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x52, RESOLUTION_ID])) await event.wait()  # Wait to receive the notification response   and parse its response (which includes the current resolution value). This is very similar to the polling example with the exception that the Query ID is now 0x52 (Register Updates for Settings). This can be seen in the raw byte data as well as by inspecting response.id.   def notification_handler(handle: int, data: bytes) -&gt; None:     logger.info(f'Received response at {handle=}: {hexlify(data, \":\")}')      response.accumulate(data)      # Notify the writer if we have received the entire response     if response.is_received:         response.parse()          # If this is query response, it must contain a resolution value         if client.services.characteristics[handle].uuid == QUERY_RSP_UUID:             global resolution             resolution = Resolution(response.data[RESOLUTION_ID][0])   This will show in the log as such:   INFO:root:Registering for resolution updates INFO:root:Received response at handle=62: b'05:52:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Successfully registered for resolution value updates. INFO:root:Resolution is currently Resolution.RES_1440   We are now successfully registered for resolution value updates and will receive push notifications whenever the resolution changes. We verify this is the demo by then changing the resolution. This will show in the log as:   INFO:root:Successfully changed the resolution INFO:root:Received response at handle=62: b'05:92:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is now Resolution.RES_1080   In this case, the Query ID is 0x92 (Setting Value Push Notification) as expected.     Multiple push notifications can be registered / received in a similar manner that multiple queries were polled in multiple simultaneous query polls   Quiz time! üìö ‚úèÔ∏è                 True or False: We can still poll a given query value while we are currently registered to     receive push notifications for it.                               A: True                                    B: False                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         While there is probably not a good reason to do so, there is nothing preventing polling         in this manner.                      True or False: A push notification for a registered setting will only ever contain query information     about one setting ID.                               A: True                                    B: False                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is B.         It is possible for push notifications to contain multiple setting ID's if both setting ID's have     push notifications registered and both settings change at the same time.        Troubleshooting   See the first tutorial‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You can now query any of the settings / statuses from the camera using one of the above patterns.   If you have been following these tutorials in order, here is an extra ü•áüçæ Congratulations üç∞üëç because you have completed all of the BLE tutorials.   Next, to get started with WiFI (specifically to enable and connect to it), proceed to the next tutorial.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/ble-queries",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 5: Connect WiFi",
        "excerpt":"This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to enable the GoPro‚Äôs WiFi Access Point (AP) so that it can be connected to. It will also provide an example of connecting to the WiFi AP.      Note! It is recommended that you have first completed the connecting, sending commands, and parsing responses tutorials before proceeding    Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 5 Folder.   Just Show me the Demo(s)!!   There are two relevant scripts that will be discussed here:      wifi_enable.py   wifi_enable_and_connect.py   If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python wifi_enable_and_connect.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   python wifi_enable_and_connect.py --help usage: wifi_enable_and_connect.py [-h] [-i IDENTIFIER]  Connect to a GoPro camera via BLE, get WiFi info, enable WiFi and connect.  optional arguments:   -h, --help            show this help message and exit   -i IDENTIFIER, --identifier IDENTIFIER                         Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used,                         first discovered GoPro will be connected to   Setup   We must first connect to BLE as was discussed in the connect tutorial. We are also using the same notification handler as was used in the sending commands tutorial   Connecting to WiFi AP   Now that we are connected via BLE, paired, and have enabled notifications, we can send the command to enable the WiFi AP.   Here is an outline of the steps to do so:      Essentially we will be finding the WiFi AP information (SSID and password) via BLE, enabling the WiFi AP via BLE, then connecting to the WiFi AP.   Find WiFi Information   Note that the process to get this information is different than all procedures described up to this point. Whereas the previous command, setting, and query procedures all followed the Write Request-Notification Response pattern, the WiFi Information is retrieved via direct Read Requests to BLE characteristics.   Get WiFi SSID   The WiFi SSID can be found by reading from the WiFi AP SSID characteristic of the WiFi Access Point service.   First, we need to define the attribute to read from:   WIFI_AP_SSID_UUID = GOPRO_BASE_UUID.format(\"0002\")   Now, let‚Äôs send the read request to get the SSID (and decode it into a string).   ssid = await client.read_gatt_char(WIFI_AP_SSID_UUID) ssid = ssid.decode()     There is no need for a synchronization event as the information is available when the `read_gatt_char` method returns.  In the demo, this information is logged as such:   INFO:root:Reading the WiFi AP SSID INFO:root:SSID is GP24500456   Get WiFi Password   The WiFi password can be found by reading from the WiFi AP password characteristic of the WiFi Access Point service.   First, we need to define the attribute to read from:   WIFI_AP_PASSWORD_UUID = GOPRO_BASE_UUID.format(\"0003\")   Now, let‚Äôs send the read request to get the password (and decode it into a string).   password = await client.read_gatt_char(WIFI_AP_PASSWORD_UUID) password = password.decode()     There is no need for a synchronization event as the information is available when the `read_gatt_char` method returns.  In the demo, this information is logged as such:   INFO:root:Reading the WiFi AP password INFO:root:Password is g@6-Tj9-C7K   Enable WiFi AP   Before we can connect to the WiFi AP, we have to make sure it is enabled. This is accomplished by using the ‚ÄúAP Control‚Äù command:                  Command       Bytes                       Ap Control Enable       0x03 0x17 0x01 0x01                 Ap Control Disable       0x03 0x17 0x01 0x00           This is done in the same manner that we did in the sending commands tutorial.   Now, let‚Äôs write the bytes to the ‚ÄúCommand Request UUID‚Äù to enable the WiFi AP!   event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x03, 0x17, 0x01, 0x01])) await event.wait()  # Wait to receive the notification response     We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback.  Note that we have received the ‚ÄúCommand Status‚Äù notification response from the Command Response characteristic since we enabled it‚Äôs notifications in Enable Notifications. This can be seen in the demo log:   INFO:root:Enabling the WiFi AP INFO:root:Received response at handle=52: b'02:17:00' INFO:root:Command sent successfully INFO:root:WiFi AP is enabled   As expected, the response was received on the correct handle and the status was ‚Äúsuccess‚Äù.   Establish Connection to WiFi AP   If you have been following through the ble_enable_wifi.py script, you will notice that it ends here such that we know the WiFi SSID and password and the WiFi AP is enabled and ready to connect to. This is because there are many different methods of connecting to the WiFi AP depending on your OS and the framework you are using to develop.   We do provide an example of this in the ble_enable_wifi_and_connect.py script. This script uses the cross-platform Wireless module from the Open GoPro Python SDK package. Note that this has been imported as such:   from open_gopro.wifi_controller import Wireless   In order to do so, perform the following after the above steps have been completed:   wifi = Wireless() wifi.connect(ssid, password)   This will log something similar to the following (it will vary slightly based on your OS):   INFO:root:Connecting to GoPro WiFi AP INFO:open_gopro.wifi_controller:Attempting to establish WiFi connection to GP24500456... INFO:open_gopro.wifi_controller:Wifi connection established! INFO:root:Wifi Connected!   Quiz time! üìö ‚úèÔ∏è                 How is the WiFi password response received?                               A: As a read response from the WiFi AP Password characteristic                                    B: As write responses to the WiFi Request characteristic                                    C: As notifications of the Command Response characteristic                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         This (and WiFi AP SSID) is an exception to the rule. Usually responses     are received as notifications to a response characteristic. However, in this case, it is     received as a direct read response (since we are reading from the characteristic and not     writing to it).                      Which of the following statements about the GoPro WiFi AP is true?                               A: It only needs to be enabled once and it will then always remain on                                    B: The WiFi password will never change                                    C: The WiFi SSID will never change                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is D.         Trick question! They are all false. While the WiFi AP will remain on for     some time, it can and will eventually turn off so it is always recommended to first connect     via BLE and ensure that it is enabled. The password and SSID will almost never change.     However, they will change if the connections are reset via Connections-&gt;Reset Connections.        Troubleshooting   See the first tutorial‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You are now connected to the GoPro‚Äôs Wifi AP and can send any of the HTTP commands defined in the Open GoPro Interface. Proceed to the next tutorial.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/connect-wifi",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 6: Send WiFi Commands",
        "excerpt":"This document will provide a walk-through tutorial to use the Python requests package to send Open GoPro HTTP commands to the GoPro.      Note! It is required that you have first completed the Connecting to Wifi tutorial.    This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab.   There are two types of responses that can be received from the HTTP commands: JSON and binary. This section will deal with commands that return JSON responses. For commands with binary responses (as well as commands with JSON responses that work with the media list), see the next tutorial.   Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 6 Folder.   Just Show me the Demo(s)!!   Each of the commands detailed below has a corresponding script to demo it. If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python wifi_command_zoom.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   $ python wifi_command_zoom.py --help usage: wifi_command_zoom.py [-h] [-z ZOOM]  Set the digital zoom level.  optional arguments:   -h, --help            show this help message and exit   -z ZOOM, --zoom ZOOM  Zoom percentage (0-100)   Setup   We must first connect to The GoPro‚Äôs WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial.   Sending HTTP Commands with JSON Responses   Now that we are are connected via WiFi, we will use the requests module to send the various HTTP commands.   Both Command Requests and Setting Requests follow the same procedure:      Send HTTP GET command to appropriate endpoint   Receive confirmation from GoPro (via HTTP response) that request was received.   GoPro reacts to command     The HTTP response only indicates that the request was received correctly. The relevant behavior of the GoPro must be observed to verify when the command's effects have been applied.       We are building the endpoints using the GOPRO_BASE_URL defined in the tutorial package's `__init__.py`  Digital Zoom   The first command we will be sending is Digital Zoom. The camera must be in the Photo Preset Group for this command to succeed. The commands writes to the following endpoint:   /gopro/camera/digital_zoom?percent=50   Let‚Äôs build the endpoint (in this example from the script, zoom is a command line argument that defaults to 50):   url = GOPRO_BASE_URL + f\"gopro/camera/digital_zoom?percent={zoom}\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Setting digital zoom to 50%: sending http://10.5.5.9:8080/gopro/camera/digital_zoom?percent=50 INFO:root:Command sent successfully INFO:root:Response: {}     The response JSON is empty. This is expected in the case of a success.  Get State                                               Send Request                                                     Parse Response                                                                The next command we will be sending is Get State. This command will return all of the current settings and values. It is basically a combination of the Get All Settings and Get All Statuses commands that were sent via BLE. Since there is no way to query individual settings / statuses via WiFi (or register for asynchronous notifications when they change), this is the only option to query setting / status information via WiFi.   The command writes to the following endpoint:   /gopro/camera/state   Let‚Äôs first build the endpoint:   url = GOPRO_BASE_URL + \"/gopro/camera/state\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   Go to the next tab for examples of viewing and parsing the response.                          The response will log as such (abbreviated for brevity):   INFO:root:Getting GoPro's status and settings: sending http://10.5.5.9:8080/gopro/camera/state INFO:root:Command sent successfully INFO:root:Response: {     \"status\": {         \"1\": 1,         \"2\": 2,         \"3\": 0,         \"4\": 255,         \"6\": 0,         \"8\": 0,         \"9\": 0,         \"10\": 0,         \"11\": 0,         \"13\": 0,         \"14\": 0,         \"17\": 1,    ...    \"settings\": {       \"2\": 9,       \"3\": 1,       \"5\": 0,       \"6\": 1,       \"13\": 1,       \"19\": 0,       \"24\": 0,       \"30\": 0,       \"31\": 0,       \"32\": 10,       \"41\": 9,       \"42\": 5,   We can see what each of these values mean by looking at the Open GoPro Interface.   For example (for settings):      ID 2 == 9 equates to Resolution == 1080   ID 3 == 1 equates to FPS == 120                    Preview Stream                                               Send Request                                                     View Stream                                                                The next command we will be sending is Preview Stream. This command will enable (or disable) the preview stream . It is then possible to view the preview stream from a media player.   The commands write to the following endpoints:                  Command       Endpoint                       start preview stream       /gopro/camera/stream/start                 stop preview stream       /gopro/camera/stream/stop           Let‚Äôs first build the endpoint:   url = GOPRO_BASE_URL + \"/gopro/camera/stream/start\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Starting the preview stream: sending http://10.5.5.9:8080/gopro/camera/stream/start INFO:root:Command sent successfully INFO:root:Response: {}     The response JSON is empty. This is expected in the case of a success.  Go to the next tab for an example of viewing the stream.                          Once enabled, the stream can be viewed at udp://@:8554.   Here is an example of viewing this using VLC:     The screen may slightly vary depending on your OS     Select Media‚Äì&gt;Open Network Stream   Enter the path as such:                     Configure Preview Stream               Select play   The preview stream should now be visible.                    Load Preset Group   The next command we will be sending is Load Preset Group. which is used to toggle between the 3 groups of presets (video, photo, and timelapse).   Let‚Äôs build the endpoint first to load the video preset group (the id comes from the command table linked above):   url = GOPRO_BASE_URL + \"/gopro/camera/presets/set_group?id=1000\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Loading the video preset group: sending http://10.5.5.9:8080/gopro/camera/presets/set_group?id=1000 INFO:root:Command sent successfully INFO:root:Response: {}     The response JSON is empty. This is expected in the case of a success.  You should hear the camera beep and move to the Video Preset Group. You can tell this by the logo at the top middle of the screen:                     Preset Group            Load Preset   The next command we will be sending is Load Preset. which is used to select a specific preset that is part of a Preset Group.   Let‚Äôs build the endpoint first to load the Cinematic Preset (the id comes from the command table linked above):   url = GOPRO_BASE_URL + \"/gopro/camera/presets/load?id=2\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Loading the cinematic preset: sending http://10.5.5.9:8080/gopro/camera/presets/load?id=2 INFO:root:Command sent successfully INFO:root:Response: {}     The response JSON is empty. This is expected in the case of a success.  You should hear the camera beep and switch to the Cinematic Preset (assuming it wasn‚Äôt already set). You can verify this by seeing the preset name in the pill at bottom middle of the screen.                     Load Preset            Get Preset Status                                               Send Request                                                     Parse Response                                                                The next command we will be sending is Get Presets Status. This command is used to get the list of all currently available presets as well as the settings that comprise each preset. This includes both default and user-defined presets.   Let‚Äôs first build the endpoint:   url = GOPRO_BASE_URL + \"/gopro/camera/presets/get\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   Go to the next tab for examples of viewing and parsing the response.                          The response will log as such (abbreviated for brevity):   INFO:root:Getting the current preset status: sending http://10.5.5.9:8080/gopro/camera/presets/get INFO:root:Command sent successfully INFO:root:Response: {     \"presetGroupArray\": [         {             \"id\": \"PRESET_GROUP_ID_VIDEO\",             \"presetArray\": [                 {                     \"id\": 6,                     \"mode\": \"FLAT_MODE_LOOPING\",                     \"titleId\": \"PRESET_TITLE_LOOPING\",                     \"userDefined\": true,                     \"icon\": \"PRESET_ICON_LOOPING\",                     \"settingArray\": [                         {                             \"id\": 2,                             \"value\": 9,                             \"isCaption\": true                         },                         {                             \"id\": 3,                             \"value\": 5,                             \"isCaption\": true                         },                         {                             \"id\": 6,                             \"value\": 1,                             \"isCaption\": true                         },                         {                             \"id\": 121,                             \"value\": 0,                             \"isCaption\": true                         }                     ],                     \"isModified\": false                 },                 {                     \"id\": 0,                     \"mode\": \"FLAT_MODE_VIDEO\",                     \"titleId\": \"PRESET_TITLE_STANDARD\",                     \"userDefined\": false,                     \"icon\": \"PRESET_ICON_VIDEO\",                     \"settingArray\": [                         {                             \"id\": 2,                             \"value\": 24,                             \"isCaption\": true                         },                         {                             \"id\": 3,                             \"value\": 8,                             \"isCaption\": true                         },                         {                             \"id\": 121,                             \"value\": 0,                             \"isCaption\": true                         }                     ],                     \"isModified\": true                 },   The JSON presetGroupArray tag is a list of presets where each preset is comprised of an ID, array of settings, and other descriptive information. In the example above, we can see that there is a user-defined looping preset and a default video preset. For more information on creating / using custom presets, see the GoPro Community Article. A future lab may be created to demonstrate parsing this JSON directly into a protobuf-compiled object.     The settings shown above are parsed the same as they were in the Get State command above  As a reader exercise, try creating a custom preset on the camera and then using this command to view its information.                    Keep Alive   The next command we will be sending is Keep Alive. which is used to prevent the camera from powering down. Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by periodically sending this message.   Let‚Äôs build the endpoint first send the Keep Alive signal:   url = GOPRO_BASE_URL + f\"/gopro/camera/keep_alive\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Sending the keep alive signal: sending http://10.5.5.9:8080/gopro/camera/keep_alive INFO:root:Command sent successfully INFO:root:Response: {}     It is recommended to send a keep-alive at least once every 120 seconds.  Set Setting   The next command will be sending is Set Setting. This end point is used to update all of the settings on the camera. It is analogous to BLE commands like Set Video Resolution.   It is important to note that many settings are dependent on the video resolution (and other settings). For example, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Check the camera capabilities to see which settings are valid for given use cases.   Let‚Äôs build the endpoint first to set the Video Resolution to 1080 (the setting_id and opt_value comes from the command table linked above):   url = GOPRO_BASE_URL + f\"/gopro/camera/setting?setting_id=2&amp;opt_value=9\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   This will log as such:   INFO:root:Setting the video resolution to 1080: sending http://10.5.5.9:8080/gopro/camera/setting?setting_id=2&amp;opt_value=9 INFO:root:Command sent successfully INFO:root:Response: {}     The response JSON is empty. This is expected in the case of a success.  You should hear the camera beep and see the video resolution change to 1080 in the pill in the bottom-middle of the screen:                     Video Resolution            As a reader exercise, try using the [Get State] command to verify that the resolution has changed.   Quiz time! üìö ‚úèÔ∏è                 What is the significance of empty JSON in an HTTP response?                               A: Always an error! The command was not received correctly.                                    B: If the status is ok (200), this is expected.                                    C: This is expected for errors (code other than 200) but not expected for ok (200).                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is B.         It is common for the JSON response to be empty if the command was received successfully     but there is no additional information to return at the current time.                      What of the following is not a real preset group?                               A: Timelapse                                    B: Photo                                    C: Burst                                    D: Video                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is C.         There are 3 preset groups (Timelapse, Photo, and Video). These can be     set via the Load Preset Group command.                      What of the following sets of FPS values are possible at 5K?                               A: [24, 25, 30]                                    B: [24, 25, 30, 60]                                    C: [24, 25, 30, 60, 120]                                    D: Any FPS is valid in at 5k                                          Submit Answer                Correct!! üòÉ          Incorrect!! üò≠ The correct answer is A.         Among these options, only 24 is possible. You're not actually expected to know     this. But you should know where to find the information: https://github.com/gopro/OpenGoPro/tree/main/docs/ble#camera-capabilities        Troubleshooting   HTTP Logging   Wireshark can be used to view the HTTP commands and responses between the PC and the GoPro.      Start a Wireshark capture on the WiFi adapter that is used to connect to the GoPro   Filter for the GoPro IP address (10.5.5.9)                     Wireshark            Good Job!     Congratulations ü§ô  You can now send any of the HTTP commands defined in the Open GoPro Interface that return JSON responses. You may have noted that we did not discuss one of these (Get Media List) in this tutorial. Proceed to the next tutorial to see how to get and perform operations using the media list.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/send-wifi-commands",
        "teaser": "/assets/images/logos/logo.png"
      },{
        "title": "Python Tutorial 7: Camera Media List",
        "excerpt":"This document will provide a walk-through tutorial to use the Python requests package to send Open GoPro HTTP commands to the GoPro, specifically to get the media list and perform operations on it (downloading pictures, videos, etc.)      Note! It is required that you have first completed the Connecting to Wifi and Sending WiFi Commands tutorials.    This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab.   Requirements   It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly.   The scripts that will be used for this tutorial can be found at in the Tutorial 7 Folder.   Just Show me the Demo(s)!!   Each of the operations detailed below has a corresponding script to demo it. If you don‚Äôt want to read this tutorial and just want to see the demo, for example, run:   $ python wifi_media_download_file.py      Note! Python 3.8.x must be used as specified in the requirements    Note that each script has a command-line help which can be found via:   $ python wifi_media_download_file.py --help usage: wifi_media_download_file.py [-h]  Find a photo on the camera and download it to the computer.  optional arguments:   -h, --help  show this help message and exit   Setup   We must first connect to The GoPro‚Äôs WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial.   Get Media List   Now that we are are connected via WiFi, we will get the media list using the same procedure to send HTTP commands as in the previous tutorial.                                               Send Request                                                     Parse Response                                                                We get the media list via the Get Media List command. This command will return a JSON structure of all of the media files (pictures, videos) on the camera with corresponding information about each media file.   Let‚Äôs first build the endpoint:   url = GOPRO_BASE_URL + \"/gopro/media/list\"   Now we send the GET request and check the response for errors. Any errors will raise an exception.   response = requests.get(url) response.raise_for_status()   Lastly, we print the response‚Äôs JSON data (nicely formatted with indent 4 using the json module):   logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\")   Go to the next tab for examples of viewing and parsing the response.                          The response will log as such (abbreviated for brevity):   INFO:root:Getting the media list: sending http://10.5.5.9:8080/gopro/media/list INFO:root:Command sent successfully INFO:root:Response: {     \"id\": \"2510746051348624995\",     \"media\": [         {             \"d\": \"100GOPRO\",             \"fs\": [                 {                     \"n\": \"GOPR0987.JPG\",                     \"cre\": \"1618583762\",                     \"mod\": \"1618583762\",                     \"s\": \"5013927\"                 },                 {                     \"n\": \"GOPR0988.JPG\",                     \"cre\": \"1618583764\",                     \"mod\": \"1618583764\",                     \"s\": \"5009491\"                 },                 {                     \"n\": \"GOPR0989.JPG\",                     \"cre\": \"1618583766\",                     \"mod\": \"1618583766\",                     \"s\": \"5031861\"                 },                 {                     \"n\": \"GX010990.MP4\",                     \"cre\": \"1451608343\",                     \"mod\": \"1451608343\",                     \"glrv\": \"806586\",                     \"ls\": \"-1\",                     \"s\": \"10725219\"                 },   The media list format is defined in the Open GoPro Specification. We won‚Äôt be rehashing that here but will provide examples below of using the media list.   One common functionality is to get the list of media file names, which can be done as such:   print([x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]])   That is, access the list at the fs tag at the first element of the media tag, then make a list of all of the names (n tag of each element) in the fs list.                    Media List Operations   Whereas all of the WiFi commands described until now have returned JSON responses, most of the media list operations return binary data. From an HTTP perspective, the behavior is the same. However, the GET response will contain a large binary chunk of information so we will loop through it with the requests library as such, writing up to 8 kB at a time:      Download Media File   The next command we will be sending is Download Media. Specifically, we will be downloading a photo. The camera must have at least one photo in its media list in order for this to work.   First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed:   media_list = get_media_list()  photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]:     if media_file.lower().endswith(\".jpg\"):         logger.info(f\"found a photo: {media_file}\")         photo = media_file         break   Now let‚Äôs build the endpoint to download the photo whose name we just found:   url = GOPRO_BASE_URL + f\"videos/DCIM/100GOPRO/{photo}\"     The endpoint will start with \"videos\" for both photos and videos  Next we send the GET request and check the response for errors. Any errors will raise an exception.   with requests.get(url, stream=True) as request:     request.raise_for_status()   Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file:   file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f:     logger.info(f\"receiving binary stream to {file}...\")     for chunk in request.iter_content(chunk_size=8192):         f.write(chunk)   This will log as such:   INFO:root:found a photo: GOPR0987.JPG INFO:root:Downloading GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987.jpg...   Once complete, the GOPR0987.jpg file will be available from where the demo script was called.   Get Media GPMF   The next command we will be sending is Get Media GPMF. More information about GPMF can be found here. Specifically, we will be downloading the GPMF for a photo. The camera must have at least one photo in its media list in order for this to work.   First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed:   media_list = get_media_list()  photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]:     if media_file.lower().endswith(\".jpg\"):         logger.info(f\"found a photo: {media_file}\")         photo = media_file         break   Now let‚Äôs build the endpoint to download the GPMF for the photo whose name we just found:   url = GOPRO_BASE_URL + f\"/gopro/media/gpmf?path=100GOPRO/{photo}\"   Next we send the GET request and check the response for errors. Any errors will raise an exception.   with requests.get(url, stream=True) as request:     request.raise_for_status()   Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file:   file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f:     logger.info(f\"receiving binary stream to {file}...\")     for chunk in request.iter_content(chunk_size=8192):         f.write(chunk)   This will log as such:   INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the GPMF for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/gpmf?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987.gpmf...   Once complete, the GOPR0987.gpmf file will be available from where the demo script was called.   Get Media Screennail   The next command we will be sending is Get Media Screennail . Specifically, we will be getting the screennail for a photo. The camera must have at least one photo in its media list in order for this to work.     There is a separate command (shown below) to get a media \"thumbnbail\"  First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed:   media_list = get_media_list()  photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]:     if media_file.lower().endswith(\".jpg\"):         logger.info(f\"found a photo: {media_file}\")         photo = media_file         break   Now let‚Äôs build the endpoint to download the screennail for the photo whose name we just found:   url = GOPRO_BASE_URL + f\"/gopro/media/screennail?path=100GOPRO/{photo}\"   Next we send the GET request and check the response for errors. Any errors will raise an exception.   with requests.get(url, stream=True) as request:     request.raise_for_status()   Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file:   file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f:     logger.info(f\"receiving binary stream to {file}...\")     for chunk in request.iter_content(chunk_size=8192):         f.write(chunk)   This will log as such:   INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the screennail for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/screennail?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987_screennail.jpg...   Once complete, the GOPR0987_screennail.jpg file will be available from where the demo script was called.   Get Media Thumbnail   The next command we will be sending is Get Media thumbnail . Specifically, we will be getting the thumbnail for a photo. The camera must have at least one photo in its media list in order for this to work.     Note! There is a separate command (shown above) to get a media \"screennail\"  First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed:   media_list = get_media_list()  photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]:     if media_file.lower().endswith(\".jpg\"):         logger.info(f\"found a photo: {media_file}\")         photo = media_file         break   Now let‚Äôs build the endpoint to download the thumbnail for the photo whose name we just found:   url = GOPRO_BASE_URL + f\"/gopro/media/thumbnail?path=100GOPRO/{photo}\"   Next we send the GET request and check the response for errors. Any errors will raise an exception.   with requests.get(url, stream=True) as request:     request.raise_for_status()   Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file:   file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f:     logger.info(f\"receiving binary stream to {file}...\")     for chunk in request.iter_content(chunk_size=8192):         f.write(chunk)   This will log as such:   INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the thumbnail for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/thumbnail?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987_thumbnail.jpg...   Once complete, the GOPR0987_thumbnail.jpg file will be available from where the demo script was called.   Troubleshooting   See the previous tutorial‚Äôs troubleshooting section.   Good Job!     Congratulations ü§ô  You can now query the GoPro‚Äôs media list and retrieve binary information for media file. This is currently last tutorial. Stay tuned for more üëç   At this point you should be able to start creating a useful example using the Open GoPro Interface. For some inspiration check out some of the demos.  ","categories": [],
        "tags": [],
        "url": "/tutorials/python/camera-media-list",
        "teaser": "/assets/images/logos/logo.png"
      }]
